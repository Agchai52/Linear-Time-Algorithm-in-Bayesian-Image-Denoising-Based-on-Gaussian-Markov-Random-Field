%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Linear-Time Bayesian Image Denoisng by GMRF                 %  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the main code file to run this method
% To run this, Average_Shift.mat is required. Average_Shift.mat is
% generated by CreatedNoisedImage.m
% To compare with other methos, NoisedData.mat is requried. NoisedData.mat
% is generated by CreatedNoisedImage.m
clc
clear all
close all

load('NoisedData_1024_30.mat') % NoisedData:size256 NoisedData_512:size512 NoisedData_1024:size1024; NoisedData_5: K=5
load('Average_Shift_1024_30.mat') % same as Noisedata
tic
K = 30; % Change it!!! [3, 5, 10, 20, 30]

% updating rate
ita_b = 1e-9; % iteration rate for b
ita_alpha = 1e-9;
ita_lambda = 1e-13;
%% Degree of Graph, Neighbor Nodes and Diagnal Vecotors.
[ny,nx] = size(I0);
n_total = ny*nx;
degree = zeros(ny,nx);
neighbor = zeros(n_total,4); % [up down left right]
psi = zeros(ny,nx);
for i = 1:ny
    for j = 1:nx
        if i~=1 && j~=1 && i~=ny && j~=ny 
            degree(i,j) = 4;
        elseif i==1 && j==1 || i==ny && j==1 || i==1 && j==nx || i==ny && j==nx
            degree(i,j) = 2;
        else
            degree(i,j) = 3;
        end
        vector_id = nx*(i-1)+j;
        id_up    = vector_id-nx;
        id_down  = vector_id+nx;
        id_left  = vector_id-1 ;
        id_right = vector_id+1 ;
        if i-1 > 0 
            neighbor(vector_id,1) = id_up;
        end
        if i+1 <= ny 
            neighbor(vector_id,2) = id_down;
        end
        if j-1 >0
            neighbor(vector_id,3) = id_left;
        end
        if j+1 <= nx
            neighbor(vector_id,4) = id_right;
        end
        psi(i,j) = 4*sin(pi*(i-1)/(2*ny))^2 + 4*sin(pi*(j-1)/(2*nx))^2;
    end
end
degree_vec = reshape(degree',[],1);
Phi = reshape(psi',[],1);

%% Vectorization
Y = zeros(n_total,K); % Y is vetor form a image. The kth column is kth image vec
for k = 1:K
    temp1 = cell2mat(I_all_ash(k));
    Y(:,k) = reshape(temp1',[],1);
end
%% Initialization

% Initial Theta_old
b0 = 0;
lambda0 = 1e-7;
alpha0 = 1e-4;
sigma_20 = 2000;
Theta_old = [b0, lambda0, alpha0, sigma_20]';

% Initial Theta
Theta = Theta_old;


% Initial m_post
Y_trans = Y';
y_hat = mean(Y_trans)';
m_post_old = y_hat;
m_post = m_post_old;
%% Iteration
epsilon = 1e-5;
iterationNum = 0;
while (iterationNum <= 100)
    Theta_old = Theta;
    b_old = Theta_old(1);
    lambda_old = Theta_old(2);
    alpha_old = Theta_old(3);
    sigma_2_old = Theta_old(4);
    sigma_2 = 0;
    dQ_lambda = 0;
    dQ_alpha1 = 0;
    dQ_alpha2 = 0;
    m_edge = 0;
    % Update the mean-vector of posterior distributions (m_post)
    for i = 1:n_total
        m_neighbor = 0;
        if neighbor(i,1)~=0
            m_neighbor = m_neighbor+m_post_old(neighbor(i,1));
        end
        if neighbor(i,2)~=0
            m_neighbor = m_neighbor+m_post_old(neighbor(i,2));
        end
        if neighbor(i,3)~=0
            m_neighbor = m_neighbor+m_post_old(neighbor(i,3));
        end
        if neighbor(i,4)~=0
            m_neighbor = m_neighbor+m_post_old(neighbor(i,4));
        end
        m_post(i) = 1/(lambda_old+alpha_old*degree_vec(i)+K/sigma_2_old)...
            *(b_old +K/sigma_2_old*y_hat(i)+alpha_old*m_neighbor);
        
        sigma_2 = sigma_2 + 1/n_total*1/(lambda_old+K/sigma_2_old+alpha_old*Phi(i));
        dQ_lambda = dQ_lambda + 0.5*1/(lambda_old+alpha_old*Phi(i)) - 0.5*1/(lambda_old+K/sigma_2_old+alpha_old*Phi(i));
    end
    % update sigma^2
    for k = 1:K
        sigma_2 = sigma_2+1/(n_total*K)*norm(m_post-Y(:,k),2)^2;
    end
    % update b
    dQ_b = (n_total*b_old +n_total*K/sigma_2_old*mean(y_hat))/(lambda_old+K/sigma_2_old)-n_total*b_old/lambda_old;
    b = b_old  + ita_b/n_total*dQ_b;
    % update lambda
    dQ_lambda = dQ_lambda - 0.5*norm(m_post,2)^2 + b^2/(2*lambda_old^2);
    lambda = lambda_old  + ita_lambda/n_total*dQ_lambda;
    % update alpha
    for i = 1:n_total
        if neighbor(i,1)~=0
            m_edge = m_edge + (m_post(neighbor(i,1))-m_post(i))^2;
        end
        if neighbor(i,2)~=0
            m_edge = m_edge + (m_post(neighbor(i,2))-m_post(i))^2;
        end
        if neighbor(i,3)~=0
            m_edge = m_edge + (m_post(neighbor(i,3))-m_post(i))^2;
        end
        if neighbor(i,4)~=0
            m_edge = m_edge + (m_post(neighbor(i,4))-m_post(i))^2;
        end     
        dQ_alpha1 = dQ_alpha1 + Phi(i)/(lambda_old+K/sigma_2_old+alpha_old*Phi(i));
    end
    m_edge = m_edge/2;
    dQ_alpha1 = dQ_alpha1 + m_edge;
    alpha = (n_total-1)/dQ_alpha1;
    for i = 1:n_total
        dQ_alpha2 = dQ_alpha2 + Phi(i)/(lambda+alpha*Phi(i));
    end
    dQ_alpha = -0.5*m_edge - 0.5*dQ_alpha1 + 0.5*dQ_alpha2;
    alpha = alpha + ita_alpha/n_total*dQ_alpha;
    
    Theta = [b, lambda, alpha, sigma_2]';
    
    iterationNum = iterationNum+1;
    %fprintf('The iteration is %d.\n',iterationNum)
    %fprintf('The error now is %f.\n',max(abs(Theta-Theta_old)))
    if max(abs(Theta-Theta_old))<epsilon
        %fprintf('The error now is %f.\n',max(abs(Theta-Theta_old)))
        break
    end
end

I_restore_ash = reshape(m_post,[nx,ny])'; % vector to image
I_restore = I_restore_ash + mean_img; % shift back
toc
% Comparison
I1 = cell2mat(I_all(1)); % linear
tic
I_VBM3D = MergeAllImages(I_all(1:K)); % VBM3D
toc
tic
I_average = AverageAllImages(I_all(1:K)); % average
toc

%% Result and Comparison
PSNR_noi = mpsnr(I1,I0)
PSNR_pro = mpsnr(I_restore,I0)
PSNR_VBM = mpsnr(I_VBM3D,I0)
% PSNR_VBMs = mpsnr(I_VBM3D_sharpen,I0)
PSNR_ave = mpsnr(I_average,I0)

% SSIM_noi = ssim(I1,I0)
SSIM_pro = ssim(I_restore,I0)
SSIM_VBM = ssim(I_VBM3D,I0)
% % SSIM_VBMs = ssim(I_VBM3D_sharpen,I0)
SSIM_ave = ssim(I_average,I0)


%% Plot 
figure,imshow(I0/255)   % ground truth
% figure,imshow(I1/255)   % noisey image
figure,imshow(I_restore/255) % restored image
figure,imshow(I_VBM3D/255) % restored image
% % figure,imshow(I_VBM3D_sharpen/255)
figure,imshow(I_average/255) % restored image
% 


